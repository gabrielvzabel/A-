<!DOCTYPE html>
<html>
<head>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.4.0/p5.js"></script>
  <style>
    /* Adicionando um estilo para o corpo da página */
    body {
      font-family: Arial, sans-serif;
      background-color: #f0f0f0;
    }

    /* Centralizando o grid */
    canvas {
      border: 1px solid black;
      margin: 20px auto;
      display: block;
    }

    /* Estilizando os inputs e botões */
    input[type="number"] {
      width: 50px;
      height: 30px;
      margin: 10px;
      padding: 10px;
      border: 1px solid #ccc;
      border-radius: 5px;
    }

    button[type="button"] {
      background-color: #4CAF50;
      color: #fff;
      padding: 10px 20px;
      border: none;
      border-radius: 5px;
      cursor: pointer;
    }

    button[type="button"]:hover {
      background-color: #3e8e41;
    }

    /* Adicionando um estilo para o container dos inputs e botões */
    .controls {
      text-align: center;
      margin: 20px;
    }

    /* Adicionando um estilo para o título */
    h1 {
      text-align: center;
      margin: 20px;
    }
  </style>
</head>
<body>
  <h1>A* Estrela</h1>
  <div class="controls">
    <input id="startX" type="number" value="0" />
    <input id="startY" type="number" value="0" />
    <input id="goalX" type="number" value="4" />
    <input id="goalY" type="number" value="4" />
    <button id="run">Run A*</button>
  </div>
  <script>
    let grid = [];
    let startX, startY, goalX, goalY;
    let path = [];

    function setup() {
      createCanvas(100, 100);
      background(255);
      grid = createGrid(5, 5);
      addObstacles(grid);
      drawGrid();
    }

    function draw() {}

    function createGrid(rows, cols) {
      let grid = [];
      for (let i = 0; i < rows; i++) {
        grid[i] = [];
        for (let j = 0; j < cols; j++) {
          grid[i][j] = false;
        }
      }
      return grid;
    }

    function addObstacles(grid) {
      grid[1][1] = true;
      grid[4][1] = true;
      grid[4][2] = true;
      grid[0][3] = true;
      grid[1][3] = true;
      grid[0][4] = true;
      grid[1][4] = true;
      grid[2][4] = true;
      grid[3][4] = true;
    }

    function drawGrid() {
      for (let i = 0; i < grid.length; i++) {
        for (let j = 0; j < grid[0].length; j++) {
          if (grid[i][j]) {
            fill(255, 0, 0); // red
          } else {
            fill(255); // white
          }
          rect(i * 20, j * 20, 20, 20);
        }
      }
    }

    function aStar(grid, start, goal) {
      let openSet = [];
      let closedSet = [];
      let path = [];

      openSet.push(start);

      while (openSet.length > 0) {
        let current = openSet[0];
        openSet.splice(0, 1);
        closedSet.push(current);

        if (current.x === goal.x && current.y === goal.y) {
          path = reconstructPath(current);
          return path;
        }

        let neighbors = getNeighbors(current, grid);

        for (let neighbor of neighbors) {
          let gScore = current.g + 1;
          let neighborNode = new Node(neighbor.x, neighbor.y, gScore, heuristic(neighbor, goal), current);
          openSet.push(neighborNode);
        }
      }

      return [];
    }

    function getNeighbors(node, grid) {
      let neighbors = [];
      for (let dx = -1; dx <= 1; dx++) {
        for (let dy = -1; dy <= 1; dy++) {
          if (dx === 0 && dy === 0) continue;
          let newX = node.x + dx;
          let newY = node.y + dy;
          if (newX >= 0 && newX < grid.length && newY >= 0 && newY < grid[0].length && !grid[newX][newY]) {
            neighbors.push({ x: newX, y: newY });
          }
        }
      }
      return neighbors;
    }

    function reconstructPath(current) {
      let path = [];
      while (current !== null) {
        path.push(current);
        current = current.parent;
      }
      path.reverse();
      return path;
    }

    function heuristic(a, b) {
      return Math.sqrt(Math.pow(a.x - b.x, 2) + Math.pow(a.y - b.y, 2));
    }

    class Node {
      constructor(x, y, g, h, parent) {
        this.x = x;
        this.y = y;
        this.g = g;
        this.h = h;
        this.parent = parent;
      }

      f() {
        return this.g + this.h;
      }

      compareTo(other) {
        return this.f() > other.f();
      }
    }

    document.getElementById('run').addEventListener('click', () => {
      startX = parseInt(document.getElementById('startX').value);
      startY = parseInt(document.getElementById('startY').value);
      goalX = parseInt(document.getElementById('goalX').value);
      goalY = parseInt(document.getElementById('goalY').value);

      let start = new Node(startX, startY, 0, heuristic(new Node(startX, startY, 0, 0, null), new Node(goalX, goalY, 0, 0, null)), null);
      let goal = new Node(goalX, goalY, 0, 0, null);

      path = aStar(grid, start, goal);
      console.log(path);

      drawPath();
    });

    function drawPath() {
      background(255);
      drawGrid();
      for (let i = 0; i < path.length; i++) {
        fill(0, 255, 0); // green
        rect(path[i].x * 20, path[i].y * 20, 20, 20);
      }
    }

    setup();
  </script>
</body>
</html>
